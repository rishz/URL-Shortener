{"version":3,"sources":["../src/app/subscribe.ts"],"names":["createSubscribe","async","LocalPromise","Promise","executor","onNoObservers","proxy","ObserverProxy","subscribe","bind","observers","unsubscribes","observerCount","task","resolve","finalized","then","catch","e","error","value","forEachObserver","observer","next","close","complete","nextOrObserver","undefined","Error","implementsAnyMethods","noop","unsub","unsubscribeOne","length","finalError","push","i","fn","sendOne","console","err","onError","args","obj","methods","method"],"mappings":"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","file":"subscribe.js","sourcesContent":["import {\n  Observer, PartialObserver, Subscribe, Unsubscribe, NextFn, ErrorFn, CompleteFn\n} from 'firebase';\nimport {local} from './shared_promise';\n\nlet LocalPromise = local.Promise as typeof Promise;\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(executor: Executor<T>,\n                                   onNoObservers?: Executor<T>)\n: Subscribe<T> {\n  let proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T>{\n  private observers: Array<Observer<T>>|undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T>|undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = LocalPromise.resolve();\n  private finalized = false;\n  private finalError: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch((e) => {\n        this.error(e);\n      });\n  }\n\n  next(value: T) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(nextOrObserver: PartialObserver<T> | Function,\n            error?: ErrorFn,\n            complete?: CompleteFn)\n  : Unsubscribe {\n    let observer: Observer<T>;\n\n    if (nextOrObserver === undefined && error === undefined &&\n        complete === undefined) {\n      throw new Error(\"Missing Observer.\");\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: (nextOrObserver as any) as NextFn<T>,\n        error: error,\n        complete: complete,\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n        return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== \"undefined\" && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: any[]) => {\n    LocalPromise.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj: any, methods: string[]): boolean {\n  if (typeof(obj) !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (let method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}"]}