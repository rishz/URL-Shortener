{"version":3,"sources":["../src/app/errors.ts"],"names":["patchCapture","ERROR_NAME","captureStackTrace","Error","captureFake","result","FirebaseError","code","message","ErrorFactory","prototype","create","err","apply","arguments","name","Object","defineProperty","get","stack","constructor","service","serviceName","errors","pattern","data","undefined","template","fullCode","replace","match","key","value","toString","prop","hasOwnProperty","slice"],"mappings":";;;;;;;;QAoDMA,Y,GAAAA,Y;;;;AAVN,IAAMC,aAAa,eAAnB;AAMA,IAAIC,oBACDC,MAAcD,iBADjB;AAGA;AACM,SAAAF,YAAA,CAAuBI,WAAvB,EAAwC;AAC5C,QAAIC,SAAcH,iBAAlB;AACAA,wBAAoBE,WAApB;AACA,WAAOC,MAAP;AACD;;IAEDC,a,GAIE,uBAAmBC,IAAnB,EACmBC,OADnB,EACkC;AAAA;;AADf,SAAAD,IAAA,GAAAA,IAAA;AACA,SAAAC,OAAA,GAAAA,OAAA;;AAEjB;AACA,QAAIN,iBAAJ,EAAuB;AACrB;AACAA,0BAAkB,IAAlB,EAAwBO,aAAaC,SAAb,CAAuBC,MAA/C;AACD,KAHD,MAGO;AACL,YAAIC,MAAMT,MAAMU,KAAN,CAAY,IAAZ,EAAkBC,SAAlB,CAAV;AACA,aAAKC,IAAL,GAAYd,UAAZ;AACA;AACAe,eAAOC,cAAP,CAAsB,IAAtB,EAA4B,OAA5B,EAAqC;AACnCC,iBAAK,eAAA;AACH,uBAAON,IAAIO,KAAX;AACD;AAHkC,SAArC;AAKD;AACF,C;AAGH;;;AACAb,cAAcI,SAAd,GAA0BM,OAAOL,MAAP,CAAcR,MAAMO,SAApB,CAA1B;AACAJ,cAAcI,SAAd,CAAwBU,WAAxB,GAAsCd,aAAtC;AACCA,cAAcI,SAAd,CAAgCK,IAAhC,GAAuCd,UAAvC;;IAEKQ,Y,WAAAA,Y;AAIJ,0BAAoBY,OAApB,EACoBC,WADpB,EAEoBC,MAFpB,EAEwC;AAAA;;AAFpB,aAAAF,OAAA,GAAAA,OAAA;AACA,aAAAC,WAAA,GAAAA,WAAA;AACA,aAAAC,MAAA,GAAAA,MAAA;AALpB;AACO,aAAAC,OAAA,GAAU,eAAV;AAKL;AACD;;;;+BAEMjB,I,EAASkB,I,EAAmC;AACjD,gBAAIA,SAASC,SAAb,EAAwB;AACtBD,uBAAO,EAAP;AACD;AAED,gBAAIE,WAAW,KAAKJ,MAAL,CAAahB,IAAb,CAAf;AAEA,gBAAIqB,WAAW,KAAKP,OAAL,GAAe,GAAf,GAAqBd,IAApC;AACA,gBAAIC,gBAAJ;AAEA,gBAAImB,aAAaD,SAAjB,EAA4B;AAC1BlB,0BAAU,OAAV;AACD,aAFD,MAEO;AACLA,0BAAUmB,SAASE,OAAT,CAAiB,KAAKL,OAAtB,EAA+B,UAACM,KAAD,EAAQC,GAAR,EAAW;AAClD,wBAAIC,QAAQP,KAAMM,GAAN,CAAZ;AACA,2BAAOC,UAAUN,SAAV,GAAsBM,MAAMC,QAAN,EAAtB,GACH,MAAMF,GAAN,GAAY,IADhB;AAED,iBAJS,CAAV;AAKD;AAED;AACAvB,sBAAU,KAAKc,WAAL,GAAmB,IAAnB,GAA0Bd,OAA1B,GAAoC,IAApC,GAA2CoB,QAA3C,GAAsD,IAAhE;AACA,gBAAIhB,MAAM,IAAIN,aAAJ,CAAkBsB,QAAlB,EAA4BpB,OAA5B,CAAV;AAEA;AACA;AACA,iBAAK,IAAI0B,IAAT,IAAiBT,IAAjB,EAAuB;AACrB,oBAAI,CAACA,KAAKU,cAAL,CAAoBD,IAApB,CAAD,IAA8BA,KAAKE,KAAL,CAAW,CAAC,CAAZ,MAAmB,GAArD,EAA0D;AACxD;AACD;AACAxB,oBAAYsB,IAAZ,IAAoBT,KAAKS,IAAL,CAApB;AACF;AAED,mBAAOtB,GAAP;AACD","file":"errors.js","sourcesContent":["/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nexport type ErrorList<T> = {[code: string]: string};\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString: () => string;\n}\n\nlet captureStackTrace: (obj: Object, fn?: Function) => void =\n  (Error as any).captureStackTrace;\n\n// Export for faking in tests\nexport function patchCapture(captureFake?: any): any {\n  let result: any = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nclass FirebaseError implements FirebaseError {\n  public stack: string;\n  public name: string;\n\n  constructor(public code: string,\n              public message: string) {\n    let stack: string;\n    // We want the stack value, if implemented by Error\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      let err = Error.apply(this, arguments);\n      this.name = ERROR_NAME;\n      // Make non-enumerable getter for the property.\n      Object.defineProperty(this, 'stack', {\n        get: function() {\n          return err.stack;\n        }\n      });\n    }\n  }\n}\n\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype) as FirebaseError;\nFirebaseError.prototype.constructor = FirebaseError;\n(FirebaseError.prototype as any).name = ERROR_NAME;\n\nexport class ErrorFactory<T extends string> {\n  // Matches {$name}, by default.\n  public pattern = /\\{\\$([^}]+)}/g\n\n  constructor(private service: string,\n              private serviceName: string,\n              private errors: ErrorList<T>) {\n    // empty\n  }\n\n  create(code: T, data?: {[prop: string]: StringLike}): Firebase.FirebaseError {\n    if (data === undefined) {\n      data = {};\n    }\n\n    let template = this.errors[(code as string)];\n\n    let fullCode = this.service + '/' + code;\n    let message: string;\n\n    if (template === undefined) {\n      message = \"Error\";\n    } else {\n      message = template.replace(this.pattern, (match, key) => {\n        let value = data![key];\n        return value !== undefined ? value.toString()\n          : '<' + key + '?>';\n      });\n    }\n\n    // Service: Error message (service/code).\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    let err = new FirebaseError(fullCode, message);\n\n    // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n    for (let prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n      (err as any)[prop] = data[prop];\n    }\n\n    return err;\n  }\n}"]}